.TH "AETimer" 3 "Fri Mar 29 2024 17:41:07" "Version v0.0.8.5a" "ArtyK's Console Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AETimer \- This module is the engine's \fBtick timer\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <AETimer\&.hpp>\fP
.PP
Inherits \fB__AEModuleBase< AETimer >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAETimer\fP (const double tps)"
.br
.RI "Class constructor -- \fBsets the delay\fP in ticks per second, and \fBstarts the thread\fP\&. "
.ti -1c
.RI "\fBAETimer\fP (void) noexcept"
.br
.RI "Class constructor -- assigns \fBdefault delay (ENGINE_FPS) and doesn't start the thread\fP\&. "
.ti -1c
.RI "\fBAETimer\fP (const \fBAETimer\fP &tm)"
.br
.RI "Copy constructor -- \fBcopies the data\fP and, if the original timer was started, \fBstarts the timer\fP\&. "
.ti -1c
.RI "\fBAETimer\fP & \fBoperator=\fP (const \fBAETimer\fP &tm)"
.br
.RI "Copy assignment operator -- \fBcopies the data\fP and, if the original timer was started, \fBstarts the timer\fP\&. "
.ti -1c
.RI "\fB~AETimer\fP (void)"
.br
.RI "\fBClass destructor\fP "
.ti -1c
.RI "void \fBstartThread\fP (void)"
.br
.RI "\fBStarts the timer thread\fP and starts tick counting\&. "
.ti -1c
.RI "void \fBstopThread\fP (void)"
.br
.RI "\fBStops the timer thread\fP and stops tick counting\&. "
.ti -1c
.RI "void \fBsetTick\fP (const \fBullint\fP tick) noexcept"
.br
.RI "Sets the timer's \fBnew tick value to the passed value\fP\&. "
.ti -1c
.RI "void \fBresetTick\fP (void) noexcept"
.br
.RI "Sets the \fBtimer tick back to 0\fP\&. "
.ti -1c
.RI "void \fBsetTPS\fP (const double tps, const \fBcint\fP flags=0)"
.br
.RI "Sets the timer's \fBnew delay as ticks-per-second\fP\&. "
.ti -1c
.RI "bool \fBisTicking\fP (void) const noexcept"
.br
.RI "Checks \fBwhether the timer is ticking\fP and the thread is running\&. "
.ti -1c
.RI "\fBullint\fP \fBgetTick\fP (void) const noexcept"
.br
.RI "Returns the \fBcurrent tick\fP of the timer\&. "
.ti -1c
.RI "long double \fBgetWorldTime\fP (void) const noexcept"
.br
.RI "Calculates the \fIapproximate world time\fP of the timer's ticks as seconds\&. "
.ti -1c
.RI "double \fBgetTPS\fP (void) const noexcept"
.br
.RI "Returns the \fBticks-per-second\fP of the \fBAETimer\fP's instance (aka \fBAEFrame\fP's fps goal)\&. "
.ti -1c
.RI "double \fBgetDelay\fP (void) const noexcept"
.br
.RI "Returns the \fBdelay-per-tick\fP of the instance, as seconds (aka \fBAEFrame\fP's delay)\&. "
.ti -1c
.RI "constexpr const \fBullint\fP \fBgetModuleID\fP (void) noexcept"
.br
.RI "Get the \fBid number of the instance\fP of the module\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBwaitForTick\fP (const \fBAETimer\fP &timer, const \fBullint\fP tick) noexcept"
.br
.RI "Stops and \fBsleeps the thread untill\fP the given timer hits \fBthe certain tick number\fP\&. "
.ti -1c
.RI "static void \fBwaitTicks\fP (const \fBAETimer\fP &timer, const \fBullint\fP tick) noexcept"
.br
.RI "Stops and \fBsleeps the thread untill\fP the given timer \fBgoes through certain amount of ticks\fP\&. "
.ti -1c
.RI "static \fBullint\fP \fBgetModuleAmount\fP (void) noexcept"
.br
.RI "Get the \fBamount of the currently-alive instances of module T\fP\&. "
.ti -1c
.RI "static constexpr const std::string_view \fBgetModuleName\fP (void) noexcept"
.br
.RI "Get the \fBname of the module\fP\&. "
.ti -1c
.RI "static constexpr const \fBullint\fP \fBgetInstanceCounter\fP (void) noexcept"
.br
.RI "Get the current value of the \fBinstance counter\fP of the module\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "const \fBullint\fP \fBm_ullModuleId\fP"
.br
.RI "The ID number of the current module\&. "
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static std::atomic< std::size_t > \fBm_ullModulesAlive\fP"
.br
.RI "Amount of the currently-alive (not destroyed) instances of the module\&. "
.ti -1c
.RI "static std::atomic< \fBullint\fP > \fBm_ullInstanceCounter\fP"
.br
.RI "Amount of the instances of the module ever created during the program's runtime\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBtickTimer\fP (void) noexcept"
.br
.RI "The function that \fBdoes the tick counting\fP for the timer\&. "
.ti -1c
.RI "\fBREGISTER_MODULE\fP (\fBAETimer\fP)"
.br
.RI "The instantiation of necessary functions from \fB__AEModuleBase\fP class\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBAEFrame\fP \fBm_rDelay\fP"
.br
.RI "The \fBframe-rater of the timer\fP for proper delay in the tick-counting function loop\&. "
.ti -1c
.RI "std::thread \fBm_trdCounting\fP"
.br
.RI "The thread object to \fBlaunch the thread\fP for the tick counting\&. "
.ti -1c
.RI "std::mutex \fBm_mtxThreadMutex\fP"
.br
.RI "The mutex to \fBsyncronise changes with the \fBAETimer::m_rDelay\fP\fP when we're touching that\&. "
.ti -1c
.RI "std::atomic< \fBullint\fP > \fBm_ullTicks\fP"
.br
.RI "The \fBtick counter\fP variable\&. "
.ti -1c
.RI "std::atomic< bool > \fBm_bRunTrd\fP"
.br
.RI "The \fBflag to continue the loop\fP for tick counting\&. "
.in -1c
.SH "Detailed Description"
.PP 
This module is the engine's \fBtick timer\fP\&. 

It allows to time or predict events ('happen at tick X'), with the variable tick speed\&. 
.br
 Internally it uses the \fBAEFrame\fP module for the delay, so the same limitations apply\&.
.PP
Internally it makes a separate thread that increments the tick number every set time period, and sleeping after\&.
.PP
\fBSee also\fP
.RS 4
\fBAEFrame\fP 
.RE
.PP
\fBNote\fP
.RS 4
This is multithreading-safe! :D 
.br
 
.RE
.PP

.PP
Definition at line \fB63\fP of file \fBAETimer\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AETimer::AETimer (const double tps)\fR [inline]\fP, \fR [explicit]\fP"

.PP
Class constructor -- \fBsets the delay\fP in ticks per second, and \fBstarts the thread\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItps\fP The amount of ticks per second, as the double
.RE
.PP

.PP
Definition at line \fB72\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBstartThread()\fP\&.
.SS "AETimer::AETimer (void)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Class constructor -- assigns \fBdefault delay (ENGINE_FPS) and doesn't start the thread\fP\&. 
.PP
Definition at line \fB80\fP of file \fBAETimer\&.hpp\fP\&.
.SS "AETimer::AETimer (const \fBAETimer\fP & tm)\fR [inline]\fP"

.PP
Copy constructor -- \fBcopies the data\fP and, if the original timer was started, \fBstarts the timer\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItm\fP The original \fBAETimer\fP instance to make a copy of
.RE
.PP

.PP
Definition at line \fB88\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_bRunTrd\fP, and \fBstartThread()\fP\&.
.SS "AETimer::~AETimer (void)\fR [inline]\fP"

.PP
\fBClass destructor\fP 
.PP
Definition at line \fB115\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBstopThread()\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBAETimer\fP & AETimer::operator= (const \fBAETimer\fP & tm)\fR [inline]\fP"

.PP
Copy assignment operator -- \fBcopies the data\fP and, if the original timer was started, \fBstarts the timer\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItm\fP The original \fBAETimer\fP instance to make a copy of
.RE
.PP
\fBReturns\fP
.RS 4
Reference to the resulting \fBAETimer\fP copy
.RE
.PP

.PP
Definition at line \fB102\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_bRunTrd\fP, \fBm_rDelay\fP, \fBm_ullTicks\fP, \fBstartThread()\fP, and \fBstopThread()\fP\&.
.SS "void AETimer::startThread (void)\fR [inline]\fP"

.PP
\fBStarts the timer thread\fP and starts tick counting\&. 
.PP
\fBNote\fP
.RS 4
Does nothing if thread is already started 
.PP
Does nothing if the previously-set delay/fps is invalid\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBAEFrame::isValidFPS()\fP 
.PP
\fBAEFrame::isValidDelay()\fP 
.PP
\fBAEFrame::hasDelay()\fP 
.RE
.PP

.PP
Definition at line \fB128\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBAEFrame::hasDelay()\fP, \fBm_bRunTrd\fP, \fBm_rDelay\fP, \fBm_trdCounting\fP, and \fBtickTimer()\fP\&.
.SS "void AETimer::stopThread (void)\fR [inline]\fP"

.PP
\fBStops the timer thread\fP and stops tick counting\&. 
.PP
\fBNote\fP
.RS 4
Does nothing if the thread was already stopped\&. 
.RE
.PP

.PP
Definition at line \fB148\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_bRunTrd\fP, and \fBm_trdCounting\fP\&.
.SS "void AETimer::setTick (const \fBullint\fP tick)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Sets the timer's \fBnew tick value to the passed value\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItick\fP The tick value to set instance's tick value to
.RE
.PP

.PP
Definition at line \fB160\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_ullTicks\fP\&.
.SS "void AETimer::resetTick (void)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Sets the \fBtimer tick back to 0\fP\&. 
.PP
Definition at line \fB167\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBsetTick()\fP\&.
.SS "void AETimer::setTPS (const double tps, const \fBcint\fP flags = \fR0\fP)\fR [inline]\fP"

.PP
Sets the timer's \fBnew delay as ticks-per-second\fP\&. 
.PP
\fBAttention\fP
.RS 4
If the value invalid, stops the thread\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBAEFrame::isValidFPS()\fP 
.RE
.PP
\fBNote\fP
.RS 4
Uses a mutex, so there \fIcould\fP be some delay\&. Check the mutex behaviour on your system\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fItps\fP The amount of ticks per second to set the delay to
.br
\fIflags\fP The flag to indicate actions after setting the fps:
.IP "\(bu" 2
\fB0\fP -- does nothing
.IP "\(bu" 2
\fB1\fP -- reset the tick amount after changing the ticks-per-second value
.IP "\(bu" 2
\fB2\fP -- approximately scale the tick counter to try to keep the world-time consistent; Uses the method of rounding indicated by \fBAETM_TICK_ROUNDING_METHOD\fP
.PP
.RE
.PP
\fBAttention\fP
.RS 4
If the previously-set delay/fps was invalid, it resets the tick value to 0, regardless of the passed \fBflags\fP value\&. 
.RE
.PP

.PP
Definition at line \fB188\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fB_AETM_TICK_ROUND\fP, \fBgetTPS()\fP, \fBAEFrame::hasDelay()\fP, \fBAEFrame::isValidFPS()\fP, \fBm_mtxThreadMutex\fP, \fBm_rDelay\fP, \fBm_ullTicks\fP, \fBresetTick()\fP, \fBAEFrame::setFps()\fP, and \fBstopThread()\fP\&.
.SS "bool AETimer::isTicking (void) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Checks \fBwhether the timer is ticking\fP and the thread is running\&. 
.PP
\fBReturns\fP
.RS 4
If the thread was started/is running:
.IP "\(bu" 2
\fBTrue\fP
.PP
.PP
Otherwise:
.IP "\(bu" 2
\fBFalse\fP 
.PP
.RE
.PP

.PP
Definition at line \fB218\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_bRunTrd\fP\&.
.SS "\fBullint\fP AETimer::getTick (void) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Returns the \fBcurrent tick\fP of the timer\&. 
.PP
\fBNote\fP
.RS 4
If thread is not started/working, the return value will be the same (duh)
.RE
.PP
\fBReturns\fP
.RS 4
Current timer tick as \fBullint\fP type\&. 
.RE
.PP

.PP
Definition at line \fB233\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_ullTicks\fP\&.
.SS "long double AETimer::getWorldTime (void) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Calculates the \fIapproximate world time\fP of the timer's ticks as seconds\&. 
.PP
\fBNote\fP
.RS 4
If thread is not started/working, the return value will be the same (duh)
.RE
.PP
\fBReturns\fP
.RS 4
The approximation of the counted world time in seconds using the timer's ticks, as the \fBdouble\fP type\&. 
.RE
.PP

.PP
Definition at line \fB245\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBAEFrame::getDelay()\fP, \fBm_rDelay\fP, and \fBm_ullTicks\fP\&.
.SS "double AETimer::getTPS (void) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Returns the \fBticks-per-second\fP of the \fBAETimer\fP's instance (aka \fBAEFrame\fP's fps goal)\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFrame::getFPS()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The ticks-per-second rate of the instance as \fBdouble\fP type\&. 
.RE
.PP

.PP
Definition at line \fB257\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBAEFrame::getFPS()\fP, and \fBm_rDelay\fP\&.
.SS "double AETimer::getDelay (void) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Returns the \fBdelay-per-tick\fP of the instance, as seconds (aka \fBAEFrame\fP's delay)\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFrame::getDelay()\fP
.RE
.PP
\fBReturns\fP
.RS 4
Delay-per-tick of the instance as seconds, as the \fBdouble\fP type\&. 
.RE
.PP

.PP
Definition at line \fB269\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBAEFrame::getDelay()\fP, and \fBm_rDelay\fP\&.
.SS "static void AETimer::waitForTick (const \fBAETimer\fP & timer, const \fBullint\fP tick)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"

.PP
Stops and \fBsleeps the thread untill\fP the given timer hits \fBthe certain tick number\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItimer\fP The instance of the \fBAETimer\fP to wait for
.br
\fItick\fP The \fBAETimer\fP instance tick value to wait for
.RE
.PP

.PP
Definition at line \fB279\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBAEFrame::sleep()\fP\&.
.SS "static void AETimer::waitTicks (const \fBAETimer\fP & timer, const \fBullint\fP tick)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"

.PP
Stops and \fBsleeps the thread untill\fP the given timer \fBgoes through certain amount of ticks\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItimer\fP The instance of the \fBAETimer\fP to wait for
.br
\fItick\fP The amount of ticks to wait for in the \fBAETimer\fP instance
.RE
.PP

.PP
Definition at line \fB292\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBwaitForTick()\fP\&.
.SS "void AETimer::tickTimer (void)\fR [inline]\fP, \fR [private]\fP, \fR [noexcept]\fP"

.PP
The function that \fBdoes the tick counting\fP for the timer\&. 
.PP
Definition at line \fB302\fP of file \fBAETimer\&.hpp\fP\&.
.PP
References \fBm_bRunTrd\fP, \fBm_rDelay\fP, \fBm_ullTicks\fP, and \fBAEFrame::sleep()\fP\&.
.SS "AETimer::REGISTER_MODULE (\fBAETimer\fP)\fR [private]\fP"

.PP
The instantiation of necessary functions from \fB__AEModuleBase\fP class\&. This is things like module names, etc\&. 
.PP
\fBWarning\fP
.RS 4
This is \fBNOT\fP a function of this class\&. Instead it's a macro call to the \fBREGISTER_MODULE()\fP in the \fBAEModuleBase\&.hpp\fP\&. 
.RE
.PP

.SS "static \fBullint\fP \fB__AEModuleBase\fP< \fBAETimer\fP  >::getModuleAmount (void)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Get the \fBamount of the currently-alive instances of module T\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fB__AEModuleBase<T>::m_ullModulesAlive\fP
.RE
.PP
\fBReturns\fP
.RS 4
Unsigned long long of the alive module amount 
.RE
.PP

.PP
Definition at line \fB122\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "static constexpr const std::string_view \fB__AEModuleBase\fP< \fBAETimer\fP  >::getModuleName (void)\fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Get the \fBname of the module\fP\&. 
.PP
\fBAttention\fP
.RS 4
You \fIneed\fP to add \fBREGISTER_MODULE()\fP to the end of the class declarations if you want to use this thing 
.RE
.PP
\fBSee also\fP
.RS 4
\fBREGISTER_MODULE()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The name of the module as a const std::strinv_view type 
.RE
.PP

.SS "constexpr const \fBullint\fP \fB__AEModuleBase\fP< \fBAETimer\fP  >::getModuleID (void)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Get the \fBid number of the instance\fP of the module\&. 
.PP
\fBRemarks\fP
.RS 4
Every module has its own instance counter
.RE
.PP
\fBReturns\fP
.RS 4
The id number of the instance of the module as \fBullint\fP type 
.RE
.PP

.PP
Definition at line \fB145\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "static constexpr const \fBullint\fP \fB__AEModuleBase\fP< \fBAETimer\fP  >::getInstanceCounter (void)\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Get the current value of the \fBinstance counter\fP of the module\&. 
.PP
\fBSee also\fP
.RS 4
\fB__AEModuleBase::m_ullInstanceCounter\fP
.RE
.PP
\fBReturns\fP
.RS 4
The amount of the module's instances overall created throughout the program's runtime 
.RE
.PP

.PP
Definition at line \fB157\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBAEFrame\fP AETimer::m_rDelay\fR [private]\fP"

.PP
The \fBframe-rater of the timer\fP for proper delay in the tick-counting function loop\&. 
.PP
\fBSee also\fP
.RS 4
\fBAETimer::tickTimer()\fP 
.RE
.PP

.PP
Definition at line \fB314\fP of file \fBAETimer\&.hpp\fP\&.
.SS "std::thread AETimer::m_trdCounting\fR [private]\fP"

.PP
The thread object to \fBlaunch the thread\fP for the tick counting\&. 
.PP
Definition at line \fB316\fP of file \fBAETimer\&.hpp\fP\&.
.SS "std::mutex AETimer::m_mtxThreadMutex\fR [private]\fP"

.PP
The mutex to \fBsyncronise changes with the \fBAETimer::m_rDelay\fP\fP when we're touching that\&. 
.PP
Definition at line \fB318\fP of file \fBAETimer\&.hpp\fP\&.
.SS "std::atomic<\fBullint\fP> AETimer::m_ullTicks\fR [private]\fP"

.PP
The \fBtick counter\fP variable\&. 
.PP
Definition at line \fB320\fP of file \fBAETimer\&.hpp\fP\&.
.SS "std::atomic<bool> AETimer::m_bRunTrd\fR [private]\fP"

.PP
The \fBflag to continue the loop\fP for tick counting\&. 
.PP
Definition at line \fB322\fP of file \fBAETimer\&.hpp\fP\&.
.SS "std::atomic<std::size_t> \fB__AEModuleBase\fP< \fBAETimer\fP  >::m_ullModulesAlive\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [inherited]\fP"

.PP
Amount of the currently-alive (not destroyed) instances of the module\&. 
.PP
Definition at line \fB166\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "std::atomic<\fBullint\fP> \fB__AEModuleBase\fP< \fBAETimer\fP  >::m_ullInstanceCounter\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [inherited]\fP"

.PP
Amount of the instances of the module ever created during the program's runtime\&. 
.PP
Definition at line \fB171\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "const \fBullint\fP \fB__AEModuleBase\fP< \fBAETimer\fP  >::m_ullModuleId\fR [protected]\fP, \fR [inherited]\fP"

.PP
The ID number of the current module\&. 
.PP
Definition at line \fB176\fP of file \fBAEModuleBase\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ArtyK's Console Engine from the source code\&.
